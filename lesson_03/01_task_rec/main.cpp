// Строка в C
// ----------
// Заканчивается на символ 0.
// "ABC" -> 'A', 'B', 'C', код 0
// strlen(S) - считает символы в строке.
//

// Генерация правильных скобочных последовательностей
// --------------------------------------------------
// N = 1
// * ()
//
// N = 2
// * (())
// * ()()
//
// N = 3
// * ((()))
// * (()())
// * ...
//
#include <iostream>
#include <cstring>
#include <cassert> // Для C++
#include <assert.h> // Для C

using namespace std;

const int MAX_N = 100;


//-->
// Готовая строка скобок
char* S;
// N - сколько пар скобок надо поставить
int N;

// На текущий момент:
// a - сколько открывающих уже стоит
// b - сколько закрывающих уже стоит
// a + b - текущая позиция в строке
void rec(int a, int b) {
  assert(0 <= a);
  assert(0 <= b);
  assert(a <= N);
  assert(b <= N);
  int k = a + b; // Текущая позиция в строке

  // Если расставили все скобки
  if(a == N && b == N) {
    S[k] = 0;
    cout << S << endl;
    return;
  }

  // Можем ли поставить открывающую?
  // Да, если открывающие ещё не кончились
  if(a < N) {
    S[k] = '('; // Ставим открывающую
    rec(a + 1, b); // Рекурсия
  }

  // Можем ли поставить закрывающую?
  // Если закрывающие ещё остались
  // и открывающих больше чем закрывающих
  if(b < N && a > b) {
    S[k] = ')'; // Ставим закрывающую
    rec(a, b + 1); // Рекурсия
  }
}

void rec() {
  //strcpy(S, "()");
  //rec(1, 1);
  rec(0, 0);
}

int main() {
  //N = 2;
  cout << "N = ";
  cin >> N;
  // Отводим память
  S = new char[N * 2 + 1];
  // Заполняем строчку нулями
  // memset( указатель, чем_заполнять, размер )
  memset(S, 0, N * 2 + 1);

  rec();

  // Очищаем память
  delete[] S;
  return 0;
}
//<--
