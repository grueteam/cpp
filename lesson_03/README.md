.\000_README.md
﻿ООП - принципы: классы, объекты, прототипы
==========================================

Объектно-ориентированное программирование (ООП, OOP): абстракция, инкапсуляция, наследование и полиморфизм
----------------------------------------------------------------------------------------------------------

Объявление класса
-----------------

Создание экземпляра
-------------------

Конструкторы и деструкторы
--------------------------

Перегрузка операторов в C++. Вывод в поток
------------------------------------------

Оператор в C++ - это некоторое действие или функция обозначенная специльным символом (символами).
Чтобы распространять действие операторов на новые (свои) типы данных в C++ их можно перегружать.

Для перегрузки используется ключевое слово **operator** вместе с прототипом и объявлением функции.


Прототипы
---------

Практика: класс "рациональная дробь"
------------------------------------

.\00_DebugMacro\main.cpp
if(a != b){ cout << __LINE__ << " " << #a << "=" << a << " != " << #b << "=" << b << endl; };
assert(c != NULL);
.\01_queue\main.cpp
Очередь
-------
На базе массива.

-------------------------------
<-|  |  |  |  |  |  |  |  |  |  | <-
-------------------------------
``` cpp
const int QUEUE_LEN = 10000;

int data[QUEUE_LEN];

int head = 0; // Индекс первого элемента очереди
int tail = 0; // Индекс первой свободной ячейки очереди

// Добавить элемент в конец очереди
void put(int value) {
  cout << "put(" << value << ")" << endl;
  data[tail++ % QUEUE_LEN] = value;
  // tail++
}

// Получить значение из начала очереди
int get() {
  return data[head++ % QUEUE_LEN];
}

bool isEmpty(){
  return head <= tail;
}

int main() {
  // Положить в очередь
  for(int i = 1; i <= 7; i++)
    put(i);

  // Извлекаем из очереди
  while(!isEmpty()){
    cout << "get() -> " << get() << endl;
  }

  return 0;
}
```

.\02_malloc_free\main.c
Отводим память
Памяти не хватило
Освобождение памяти
.\04_inherit\main.cpp
privateA = 1; // Невозможно
b1.forChilds = 5;
.\04_static_stack\main.c
int localArray[100];
Динамическая память
.\05_Assert\main.cpp
.\05_StackDemo\main.cpp
Текущий размер стека
Положить данные на вершину стека
Забрать данные с вершины стека
.\05_inherit_sameName\main.cpp
.\05_new_delete\main.cpp
Отводим динамическую память
Освобождаем динимическую память
"Заводим" массив в динамической памяти
Освобождаем память
.\06_references\main.cpp
int &bb;  // error: 'bb' declared as
reference but not initialized
&b = d; // Нельзя переопределять ссылки
Указывает на переменную a
.\07_task_large_arrays\main.cpp
#include <stdlib.h>
int A[]
int &A[]
/*, int arraySize*/ /* параметры */
Предположим, что максимум это первый элемент
Пробежим по остальным элементам массива
если какой-то элемент больше текущего
максимума, то запомним новый текущий максимум
Массив в стеке
Заполняем случайными числами
.\08_OOP_Simplest\main.cpp
Простейший пример ООП
Создали класс точка
Массив из точек
p[0].x
p[0].y
Класс = данные + методы работы
Повернуть точку относительно начала координат
...
public / private / protected
Два отдельных массива
ООП
Динамическая память
...
Создаю массив объектов
Удаляю
.\08_ref_demo\main.cpp
int & - объявляем ссылку
только с 2-мя именами
ptrA - указатель, valueA - значение
переменную value
*ptrA и value - одна и та же переменная
.\09_constructor_destructor\main.cpp
struct - С
class - С++
Ключевое слово class
Имя_класса
Количество объектов
Идентификатор данного объекта
Конструктор
Деструктор
Инициализация static-переменной
.\09_list\main.cpp
Указатель на первый элемент списка
Добавить в начало списка
Удалить первый элемент списка
Проверяем что список пуст
и если это так, выводим сообщение
об ошибке и выходим из функции
Запоминаем ссылку на перый элемент
Переместим корень (указатель на начало
списка) на второй элемент
Теперь мы можем удалить первый элемент
т.к. ссылка на второй элемент
уже сохранена
.\09_ref_array\main.cpp
int& B[100] = A;
cout << &*Y /* <=> */ Y
.\10_copy_contructor\main.cpp
Класс "строка"
Конструктор
Вывод строки на экран
Деструктор
Перегрузка операции присваивания
if(Str != NULL)
delete[] Str;
Конструктор копирования
Создает копии динамических переменных и ресурсов
if(Str != NULL)
delete[] Str;
.\11_inherit\main.cpp
Наследование
struct A <--> class A { public:
class A <--> struct A { private:
Недоступна в наследниках
onlyInA = 2;
cout << "onlyInA = " << onlyInA << endl;
Множественное наследование
show(); // Ошибка компиляции
Мы должны явно указать из какого предка вызываем метод
потому что это глобальная переменная
a.onlyInA = 3; // 'int A::onlyInA' is private
'int A::forChilds' is protected
cout << a.forChilds << endl;
Нет доступа, т.к. onlyInA private
b.onlyInA = 10;
c.a = 1; // Ошибка из-за protected наследования
c.b = 2; // Ошибка из-за protected наследования
c.doA();
c.doB();
x.doL();
.\14_polymorph\main.cpp
Фигура
virtual void show(){
cout << "Shape" << endl;
};
virtual void doA() = 0;
virtual void doB() = 0;
virtual void doC() = 0;
virtual void doD() = 0;
virtual void doE() = 0;
int x;
Shape shape; // Ошибка компиляции
new Shape(),
.\16_rational\main.cpp
typedef long long ll;
НОД - Наибольший общий делитель
Рациональная дробь: p/q
Сокращение дроби
Сокращаем дробь если надо
Если знаменатель равен 1
то это целое число
Целая часть
Если число целое, то должно было сработать
первое условие (1)
TODO: Конструктор
if(q == 0){
cout << "q == 0" << endl;
halt(1);
}
Показать дробь на экран (в консоль)
Сложение дробей
p    right.p
--- + -------
q    right.q
--------------------------
Для предотвращения переполнений
a + b
--------------------------
Конструктор копирования
cout << r.p << "/" << r.q << endl;
cout << "Copy contructor " << p << "/" << q << endl;
SHOW(a / b);
SHOW(a * b);
Rational c = b + a;
.\17_iterator\main.cpp
Итерируемся по set
for(vector<int>)
.\19_this_demo\main.cpp
Демонстрация работы с this
.\20_setter_getter\main.cpp
setter - метод для установки значения поля
getter - метод для получения значения поля
.\21_getter_setter_square\main.cpp
Пример: зачем нужны get/set методы
Don’t Repeat Yourself
http://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself
.\21_getter_setter_square\square.cpp
side = sqrt(value);
.\21_getter_setter_square\square.h
Инкапсуляция
private: // Инкапсуляция
double side;
Получить сторону квадрата
return side;
Задать сторону квадрата
side = value;
Получить площадь
return side*side;
Задать площадь
.\22_vectors\main.cpp
Конструктор - вызывается после создания объекта в памяти
Деструктор - вызывается перед удалением объекта из памяти
Конструктор копирования
.\23_list\main.cpp
Реализация структуры данных "Список"
Элемент списка
Список целиком
Конструктор
Так нельзя (!!!):
root->next = NULL;
Деструктор - метод, который вызывается при
уничтожении объекта
Добавить в начало списка
Заводим новый элемент списка в динамической памяти
Записываем в него новое значение
(*newElement).value = newValue;
Этот элемент должен встать в начало списка,
т.е. все остальные элементы будут после него.
Показать список
Текущий элемент - сначала 1-ый
Добавить элемент в конец списка
Идём до последнего элемента
for(ListElement* cur = root;
cur->next != NULL; cur = cur->next)
/* Ничего не надо делать :) */;
Создаём новый элемент
Новый элемент ставим в конец списка
Удаляем элемент списка по значению
Если список пуст, то искать в нём нечего
Если первое значение подходит, то удаляем первый элемент
Ищем значение
Ничего не нашли
Мы нашли элемент, который хотим удалить и это
Соединяем "концы" цепочки
Удаляем элемент с заданным индексом
Если список пуст, то искать в нём нечего
Если первое значение подходит, то удаляем первый элемент
Ищем значение
Ничего не нашли
Мы нашли элемент, который хотим удалить и это
Соединяем "концы" цепочки
List - класс
list - объект этого класса
.\24_ListExample\main.cpp
Один элемент списка
следующий элемент списка
Список целиком, с всеми операциями
Указатель на первый элемент списка
ListElement *root = NULL;
Конструктор - метод, который вызывается
при создании объекта (экземпляра класса)
NULL - означает что нет ни одного элемента в списке
Деструктор (очистка памяти)
Запоминаем 2-ой элемент списка
(следующий после первого элемента)
Удаляем первый элемент списка
delete:
1. Вызывается деструктор (если есть)
2. Освобождается динамическая память
Показать список
cur->value <-> (*cur).value
Добавить элемент в начало
Заводим новый элемент в динамической памяти
Заполняем новый элемент
Подвешиваем к новому элементу старый список
Теперь root должен ссылаться на новый элемент
Добавить элемент в конец
Если список пуст, то добавить в конец
это то же что и добавить в начало
Ищем последний элемент
Убеждаемся в том, что это последний элемент
списка
Заводим новый элемент
Подвешиваем новый элемент в конец списка
.\26_private_constructor_singletone\main.cpp
Для чего использовать private-конструкторы
Создаем класс S
Задача: сделать чтобы в программе
был только один экземпляр этого класса
Singletone / Одиночка
private: // по-умолчанию и так private
private (частный) конструктор
Один-единственный экземпляр класса S
Единственный способ получить экземпляр
класса S - вызвать этот метод
S s1;
S *s = new S;
.\HomeWork\main.cpp
Элемент стека и очереди
Стек
Конструктор
Значение поместить на вершину стека
TODO: реализовать
Взять значение с вершины стека
TODO: реализовать
Доп. задание: очередь
Конструктор
В конец очереди
TODO: реализовать
Забрать первый элемент из очереди
TODO: реализовать
.\HomeWork\task.cpp
Домашнее задание:
Реализовать стек и очередь
Элемент стека и очереди
Стек
Конструктор
Значение поместить на вершину стека
Взять значение с вершины стека
Конструктор
В конец очереди
Забрать первый элемент из очереди
.\HomeWork_Done\main.cpp
Элемент стека и очереди
Стек
Конструктор
Значение поместить на вершину стека
Записываем значение,
которое надо поместить
на вершину стека
Новый элемент на вершине стека
поэтому все остальные следуют за ним
Ставим новый элемент в начало списка
Взять значение с вершины стека
Запоминаем результат
- значение элемента-"вершины" стека
1-A
Запоминаем ссылку на удаляемый
элемент
1-B
2. Перемещаем вершину на следующий
3. Реально удаляем элемент
4. Возвращаем результат
Конструктор
В конец очереди
Создаём новый элемент
Если очередь пуста
Если в очереди уже есть элементы
"Присоединяем" элемент к последнему
элементу в очереди
Забрать первый элемент из очереди
Запоминаем первый элемент
Значение, которое мы в конце вернём
Передвигаем указатель на начало
очереди на следующий элемент
Если очередь пуста, то
хвост очереди не указывает ни на
какой элемент
Удаляем первый элемент из
динамической памяти
Возвращаем его значение
.\HomeWork_Done\task.cpp
Домашнее задание:
Реализовать стек и очередь
Элемент стека и очереди
Стек
Конструктор
Значение поместить на вершину стека
Взять значение с вершины стека
Конструктор
В конец очереди
Забрать первый элемент из очереди
.\cin_cout\main.cpp
cin >> p1.x >> p1.y;
cin.getline(str, 1024);
Вывести на экран точку 1
cin.clear();
.\diamond_inherit\main.cpp
Diamond Inheritance
Полиморфизм
.\memory\main.cpp
Заводим в динамической памяти массив из 100 элементов
с типом int
Удалили
*(intPtr + 19*sizeof(int));
.\not_init\main.cpp
.\string_overflow\main.cpp
``` cpp
union Bytes {
  int i; // Тип int занимает 4 байта
  char bytes[4]; // Он же в виде 4-х отдельных
};
```

``` cpp
struct Shape {
  char type; // type = 'C' - круг, 'S' - квадрат
  double x, y;
  union {
    double R;
    double Side;
  };
};
```

``` cpp
struct Point {
  double x, y;

  // Расстояние между точками
  double dist(Point b) {
    return sqrt(pow(x - b.x, 2) +
                pow(y - b.y, 2));
  }

};
```

SetConsoleCP(1251); // Ввод с консоли в кодировке 1251
SetConsoleOutputCP(1251); // Вывод на консоль в кодировке 1251.
``` cpp
  char str[10]; // Строка до 9 символов, последний символ 0

  cout << "Введите строку больше 10 символов: ";
  cin >> str;

  freopen("result.txt", "w", stdout);
  cout << str << endl;
``` cpp

  int i = 0;
  i++;

  return 0;
}
