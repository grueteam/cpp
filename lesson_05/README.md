.\000_intro.md

﻿Template. Шаблонные функции. Стратегии
======================================

Обобщённое программирование
---------------------------
*Обобщённое программирование (generic programming)* - парадигма программирования, заключающаяся в таком описании *структур данных* и *алгоритмов*,
которое можно применять к различным типам данных, не меняя само описание.

В C++ ООП реализуется посредством виртуальных функций и наследования, а ОП — с помощью шаблонов классов и функций.

Этапы в решении задачи по методологии ОП:
* Найти полезный и эффективный алгоритм.
* Определить обобщённое представление (параметризовать алгоритм, минимизировав требования к обрабатываемым данным).
* Описать набор (минимальных) требований, удовлетворяя которые всё ещё можно получить эффективные алгоритмы.
* Создать каркас на основе классифицированных требований.

Описание шаблона. Шаблонные функции (min, max и т.д.). Шаблонные классы
-----------------------------------------------------------------------

```cpp
// Описание шаблона функции
template <typename T> T max(T x, T y) {
  if (x < y)
    return y;
  else
    return x;
}
...
// Применение функции, заданной шаблоном
int a = max(10,15);
...
double f = max(123.11, 123.12);
...
```

Контейнеры
----------

Стандартная библиотека шаблонов STL: контейнеры, итераторы, алгоритмы, адаптеры, функторы (vector, algorithm)
-------------------------------------------------------------------------------------------------------------





.\01_static\main.cpp
Нестатический метод
.\01_template_min_max\main.cpp
Базовое применение шаблонов
Без использования шаблонов
T - параметр шаблона
Шаблонная функция
Предусловия
Параметры шаблонов:
типы: class G / typename T
любой из типов: int I
Функция, добавляющая константу
assert(2*2 == 5);
.\02_const\main.cpp
ООП, модификатор const
const: общий смысл - "нельзя менять"
C: struct, class - нет
C++: struct - public, class - private
x++;
message[2] = 'A';
increment of read-only variable 'i'|
i++;
p.move(2,3); // Нельзя
.\02_operators\main.cpp
Перегрузка операторов
-----------------------
В C++ возможна перегрузка:
арифметических операций
+ - * /
Перегрузка операций сравнения
> < >= <= == !=
Операции вывода в поток, ввода с клавиатуры
>> <<
#include <assert.h> // для С
#define DEBUG1
Рациональная дробь: p/q
Getters - методы доступа к данным
Setters
void setP(T value){ p = value; }
a + b
Ввод из потока
Ключевое слово friend - функция имеет доступ к закрытым (private/protected)
членам класса (полям и методам)
Вывод в поток
Наибольший общий делитель
template <class T = int>  // Параметр шаблона "по-умолчанию"
class Rational {
T GCD(T, T);
Сокращение дроби
Находим НОД числителя и знаменателя
Делим числитель и знаменатель на НОД
if(q == 0){
cout << "q == 0" << endl;
halt(1);
}
p/q + right.p/right.q
--------------------------
--------------------------
------------
------------
Сокращаем дробь если надо
Шаблонный "шаблонный" параметр
Класс, который является шаблоном можно передавать как параметр
другому классу-шаблону, при этом параметр вложенного шаблона
.\02_template_duck_typing\main.cpp
Утиная типизация
Duck Typing
.\03_print_commas\main.cpp
a - массив
N - количество элементов
T - параметр шаблона
произвольный тип, с которым можно выполнять
операции (т.е. он подходит по duck typing)
Вывести через запятую
2, 3, 4
.\03_template_stack_queue\main.cpp
template <class T>
template <typename T>
Элемент стека и очереди
Стек
Конструктор
Значение поместить на вершину стека
Записываем значение,
которое надо поместить
на вершину стека
Новый элемент на вершине стека
поэтому все остальные следуют за ним
Ставим новый элемент в начало списка
Взять значение с вершины стека
Запоминаем результат
- значение элемента-"вершины" стека
1-A
Запоминаем ссылку на удаляемый
элемент
1-B
2. Перемещаем вершину на следующий
3. Реально удаляем элемент
4. Возвращаем результат
Конструктор
В конец очереди
Создаём новый элемент
Если очередь пуста
Если в очереди уже есть элементы
"Присоединяем" элемент к последнему
элементу в очереди
Забрать первый элемент из очереди
Запоминаем первый элемент
Значение, которое мы в конце вернём
Передвигаем указатель на начало
очереди на следующий элемент
Если очередь пуста, то
хвост очереди не указывает ни на
какой элемент
Удаляем первый элемент из
динамической памяти
Возвращаем его значение
.\04_template_int\main.cpp
.\05_template_sum\main.cpp
Задача:
Функция, вычисляющая сумму элементов
массива с произвольным типом данных.
Понятно, что функция применима только если
элементы массива поддерживают операцию
сложения "+"
Универсальная функция суммирования
Отдельная функция для суммирования строк
Комплексное число
re - действительная часть
im - мнимая часть
Строки тоже можно "суммировать"
Это называется "Конкатенация строк"
.\06_template_sort\main.cpp
Демонстрация "зачем нужны шаблоны"
Задача: мы хотим написать функции сортировки для всех типов данных
Если не использовать шаблоны,
то для 2 типов (int, сhar) требуется две реализации
функции сортировки
Используем простейший алгоритм сортировки
На i-ом шаге сделаем, чтобы на i-ом месте
был минимальный элемент на отрезке массива от i до конца массива
i - начало интервала, пусть j пробегает все элементы после i
на i-ом месте
Меняем два элемента
чтобы на i-ом месте стоял минимальный
элемент
Вторая реализация точно такая же, но int заменяем на char
Меняем два элемента
чтобы на i-ом месте стоял минимальный
элемент
Универсальная сортировка
template <class T>
Меняем два элемента
чтобы на i-ом месте стоял минимальный
элемент
Массив целых чисел
s<int>(a,3)
Массив букв
Можно применить и к действительным числам
..и к строкам...
...и к любым другим типам данных (в том числе своим)..
..к которым применима операция "меньше"..
.\08_template_many_functions\main.cpp
error: no matching function for call to 'add(int&)'|
.\09_vector\main.cpp
string vv[4];
.\10_files\main.cpp
.\10_vector\main.cpp
.\11_iostream\main.cpp
.\11_sort_strings\main.cpp
Задача
Ввести из файла in.txt количество строк N
Ввести из файла N строк
Отсортировать их и вывести в файл
out.txt
Вектор для хранения строк
Открываем входной файл
Считываем сами строки
in.eof() in.good() - до конца файла
Сортируем
Открываем файл для вывода
Выводим строки
Закрываем файл
.\12_sort_my_comparator\main.cpp
sort algorithm example
using default comparison (operator <):
myvector.size()
using function as comp
Сортировка в обратном порядке
using object as comp
print out content:
.\13_set\main.cpp
.\14_set_test\main.cpp
.\HomeWork\main.cpp
Словарь
Чтение словаря из файла
from - слово на исходном языке
to - перевод
from - ключ, to - значение
dict[from] = to;
out << dict.find(s) << " " << dict.end() << endl;
.\InputWidgets\main.cpp
.\InputWidgets\mainwindow.cpp
Новый выбранный шрифт
.\InputWidgets\mainwindow.h
.\l5_inherit2\main.cpp
.\l5_inherit\main.cpp
Наследование
Полиморфизм
.\l5_oop\main.cpp
.\l5_shapes\main.cpp
Базовый класс "Фигура"
Круг - 1-ый наследник
Прямоугольник - 2-ой наследник
Конструктор
Выводим на экран
.\l5_template2\main.cpp
MyClass c1, c2;
add<MyClass>(c1,c2);
.\l5_template\main.cpp
template
Реализация структуры данных "Список"
template<class A,class B>
void f(A a, B b){

}
Элемент списка
Конструктор
Так нельзя (!!!):
root->next = NULL;
Деструктор - метод, который вызывается при
уничтожении объекта
Добавить в начало списка
Заводим новый элемент списка в динамической памяти
Записываем в него новое значение
(*newElement).value = newValue;
Этот элемент должен встать в начало списка,
т.е. все остальные элементы будут после него.
Показать список
Текущий элемент - сначала 1-ый
Добавить элемент в конец списка
Идём до последнего элемента
for(ListElement* cur = root;
cur->next != NULL; cur = cur->next)
/* Ничего не надо делать :) */;
Создаём новый элемент
Новый элемент ставим в конец списка
myFunction<double>()
make_pair(234, 'c');
List - класс
list - объект этого класса
.\liter.md

﻿Литература по Qt
----------------
* Боровский А. Qt 4.7+ Практическое программирование на C++. — СПб.: «БХВ-Петербург», 2012. — С. 496. — ISBN 978-5-9775-0757-8.
* Макс Шлее Qt 4.8 Профессиональное программирование на C++. — СПб.: «БХВ-Петербург», 2012. — С. 912. — ISBN 978-5-9775-0736-3.
* Саммерфилд М. Qt. Профессиональное программирование. Разработка кроссплатформенных приложений на С++. — СПб.: «Символ-Плюс», 2011. — С. 560. — ISBN 978-5-93286-207-0.
* Макс Шлее Qt 4.5 Профессиональное программирование на C++. — СПб.: «БХВ-Петербург», 2010. — С. 896. — ISBN 978-5-9775-0398-3.
* Ж. Бланшет, М. Саммерфилд Qt 4: Программирование GUI на C++. 2-е дополненное издание. — М.: «КУДИЦ-ПРЕСС», 2008. — С. 736. — ISBN 978-5-91136-059-7.
* Земсков Ю.В. Qt 4 на примерах. — СПб.: «БХВ-Петербург», 2008. — С. 608. — ISBN 978-5-9775-0256-6.
* Ж. Бланшет, М. Саммерфилд Qt 4: Программирование GUI на C++. — М.: «КУДИЦ-ПРЕСС», 2007. — С. 648. — ISBN 978-5-91136-038-2.
* Макс Шлее Qt 4: Профессиональное программирование на C++. — СПб.: «БХВ-Петербург», 2007. — С. 880. — ISBN 978-5-9775-0010-6.
* Чеботарев А. Библиотека Qt 4. Создание прикладных приложений в среде Linux. — М.: «Диалектика», 2006. — С. 256. — ISBN 5-8459-0996-1.



