.\000_intro.md
Введение в C++
==============

Языки высокого и низкого уровня
-------------------------------

*Высокоуровневый язык программирования* - язык, нацеленный на *скорость* и *удобство* разработки (удобство программиста)
в том числе за счёт понижения эффективности использования *памяти* и процессорного *времени*.
Приближен к естественному языку.
Основная черта высокоуровневых языков - это *абстракция*, то есть введение смысловых конструкций,
кратко описывающих такие структуры данных и операции над ними,
описания которых на машинном коде (или другом низкоуровневом языке программирования) очень длинны и сложны для понимания.

*Язык низкого уровня* - близок к программированию непосредственно в машинных кодах
(или на ассемблере) используемого реального или виртуального (например, Java, Microsoft .NET) процессора.

Фокус на *скорости* и *эффективности* использования памяти.

*Основные преимущества языков низкого уровня:*
* эффективное использование процессорного времени и памяти.
* часто язык низкого уровня позволяет обратиться к ресурсам, недоступным из языка высокого уровня.
* как правило, размер исполняемого файла готовой программы получается меньше.

История создания языка C, история C++. Перспективы - язык D
-----------------------------------------------------------
* Разработан в 1972 - Деннис Ритчи, Кен Томпсон
* 1978 - Брайан Керниган и Деннис Ритчи опубликовали первую редакцию книги "Язык программирования Си"
* 1983 - Американский национальный институт стандартов (ANSI) сформировал комитет для разработки стандартной спецификации Си
* 1989 - ANSI C. Утверждён "Язык программирования Си" ANSI X3.159-1989.
* 1990 - Стандарт ANSI C был принят с небольшими изменениями Международной организацией по стандартизации (ISO) как ISO/IEC 9899:1990.
* 1999 - Стандарт C99.
* 8 декабря 2011 опубликован новый стандарт для языка Си (ISO/IEC 9899:2011).
* Язык D - http://dlang.org. Примеры на языке D: https://github.com/stden/dlang

Выбор компилятора и IDE
-----------------------
* GCC - GNU Compiler Collection - кроссплатформенный компилятор
* Visual C++ Compiler - колимпилятор под Windows от Microsoft

Установка IDE Code::Blocks. Запуск программы. Отладка
-----------------------------------------------------
* Code::Blocks: http://www.codeblocks.org/downloads/binaries - выбирайте версию вместе с MinGW (например: codeblocks-13.12mingw-setup.exe)

Программа "Hello world!" на C и на C++. Отличия С и C++
-------------------------------------------------------
* [Hello world C++](/lesson_01/00_first/helloworld.cpp)
* [Hello world C](/lesson_01/00_first/helloworld.c)

Ввод и вывод данных (консоль) в C и в C++. Ввод и вывод из текстового файла
---------------------------------------------------------------------------


Литература по C/C++
-------------------
* https://vk.com/cpp_junior_developer - группа ВКонтакте

Пример: https://ideone.com/q9Vglz
Среда разработки в облаке: https://ideone.com


.\00_codeblocks\README.md
Установка и настройка Code::Blocks
==================================

**Code::Blocks** - среда разработки для C/C++.

* http://www.codeblocks.org/downloads/binaries - Среда разработки Code::Blocks (C/C++) вместе с библиотеками OpenGL

Варианты
--------
* **codeblocks-13.12-setup.exe** - только среда разработки без компилятора и отладчика.
* **codeblocks-13.12mingw-setup.exe** - IDE + MinGW (компилятор + отладчик).
* **codeblocks-13.12mingw-setup-TDM-GCC-481.exe** - IDE + Альтернативный компилятор и отладчик.

Шаги по установке
-----------------
* Скачиваем **codeblocks-13.12mingw-setup.exe**
* Устанавливаем _скриншоты_
* Настройки компилятора MinGW
* Создание консольного проекта (пример со скриншотами)
* Шаблон проекта

Установка Code::Blocks
----------------------
Запускаем скачанный **codeblocks-13.12mingw-setup.exe**

![Code::Blocks](step1.png "Установка 1")

Соглашаемся с лицензией:

![Code::Blocks](step2.png "Установка 2")


``` cpp

```

![Code::Blocks](CodeBlocks.png "Среда разработки Code::Blocks")


.\01_first\helloworld.c
Первая программа на чистом C
----------------------------
Подключаем библиотеку: **stdio.h**
``` cpp
/* Hello World на C */
#include <stdio.h> /* Подключаем библиотеку */
#include <stdlib.h> /* ..ещё одну библиотеку */
// #include <iostream> // Для C++

int main() {
  printf("C: Hello world!\n");
  // std::cout << "Test" << std::endl;  // Для C++
  return 0;
}
```

.\01_first\helloworld.cpp
* В C++ используем библиотеку STL **iostream**
``` cpp
// Hello World на C++
#include <iostream>

using namespace std;

int main() {
  cout << "C++: Hello world!" << endl;
  return 0;
}
```

.\01_first\main.cpp
Общая структура программы. Использование комментариев (практика: комментарии до кода)
-------------------------------------------------------------------------------------
Подключение библиотек:
Заголовочные файлы в C++ без расширения
``` cpp
#include <iostream>
#include <cstdlib>
```

Глобальные переменные:
``` cpp
int x = 1, y = 10;
```

Функции:
``` cpp
int f() {
  return 1;
}
```

Основная программа - функция *main*
``` cpp
using namespace std; // Пространство имён, чтобы не писать везде std::cin

int main() { // Основная функция
  cout << "Enter two numbers: "; // Выводим на экран
  int a, b; // Объявляем 2 переменные целого типа
  std::cin >> a >> b; // Вводим их с клавиатуры
  std::cout << a << " + " << b << " = " << a + b << std::endl; // Вывод суммы
  system("pause"); // Нажмите любую клавишу...
  return 0; // Программа завершилась удачно, 0 - код возврата
}
```

.\01_first_C\main.c
Подключение библиотек
#include "MyLib.h" - ваша библиотека
Своя функция
F9 - компиляция и запуск на выполнение
с ожиданием в конце нажатия клавиши
.\01_first_Cpp\main.cpp
Подключение библиотек
Основная программа
Вывод на экран строчки
int c = 1+2;
cin >> c;
a = 10;
c += a += 2;
SHOW(c);
Обмен двух переменных значениями
без третьей переменной
Код возврата
.\01_helloworld2_c\main.c
Чистый C
#include <stdlib.h>
.\01_helloworld2_cpp\main.cpp
C++
Вывод в консоль по-русски:
``` cpp
  setlocale(LC_ALL, "Russian");
```

.\01_helloworld_c\main.c
cp866 win1251
.\01_helloworld_cpp\main.cpp
Ввод и вывод данных (консоль) в C и в C++. Ввод и вывод из текстового файла
---------------------------------------------------------------------------
Программа, которая складывает два числа
Ввод и вывод из текстового файла
Раскомментировать для ввода из файла
freopen("input.txt", "r", stdin);
Раскомментировать для вывода в файл
freopen("result.txt", "w", stdout);
static int a = 3;
Ввод двух чисел
cout << "Введите A и B: ";
Сложение
Вывод результата
.\02_BuildCmdLine\README.md
Скрипт для сборки из командной строки Windows
---------------------------------------------
``` bat
@echo Build exe-file:
g++ a.cpp -Wall -O3 -o MyFile.exe
@echo Run file:
MyFile.exe
```

.\02_BuildCmdLine\a.cpp
Сборка из командной строки
--------------------------
``` cpp
#include <iostream>

int main() {
  int i = 2 * 3;
  std::cout << "Hello world! " << i << std::endl;
  return 0;
}
```

.\02_HelloWorld_C\main.c
На чистом C можно писать void main
программа при этом будет иметь код возврата 0
На C++ обязательно *int main* и *return 0;*
``` cpp
void main() {
  printf("Hello world!\n");
  return; // 0;
}
```

.\02_MyCout\main.cpp
.\02_a_plus_b\main.cpp
тип имя_переменной_1, имя_переменной_2;
.\02_bit_operators\main.cpp
Побитовые операции с целыми числами
-----------------------------------
Каждый бит как логическая переменная
Пространства имён
``` cpp
namespace A {
int a;
}

namespace B {
int a;
}
```

``` cpp
int main() {
  A::a = 1;
  B::a = 2;
  // >> - побитовые сдвиг вправо
  // 101111 -> 001011
  // << - побитовые сдвиг влево
  // 00101111 -> 10111100
  int c = 3 + 5 >> 1;
  // 5 >> 1
  // 101 >> 1 -> 10

  int lp = 10 << 2;

  // Логические операции (побитовые)
  // & - И (AND)
  // 0011 & 0101 => 0001
  // | - ИЛИ (OR)
  // 0011 & 0101 => 0111
  //  0 0  -> 0
  //  0 1  -> 1
  //  1 0  -> 1
  //  1 1  -> 1
  // ^ - Исключающее ИЛИ (XOR) - не равно
  // 0011 & 0101 => 0110
  //  0 0  -> 0
  //  0 1  -> 1
  //  1 0  -> 1
  //  1 1  -> 0

  // ~ - Инверсия (NOT)
  // ~01 => 10
  // 3 = 11
  int k = ~1 & 3; // 01 -> 10
  cout << "k = " << k << endl;

  //c = 2, A::a = 4 + A::b;
  cout << "c = " << c << endl;
  return 0;
}
```

.\02_hw_c_qt\main.c
Пример с файлом проекта для Qt
------------------------------
Вывод Hello World на экран
.\02_int_operations\main.cpp
Арифметические операции
-----------------------
``` cpp
  int a; // "int" - тип переменной, "a" - имя переменной
  cout << "a = ";
  cin >> a;

  cout << "b = ";
  int b;
  cin >> b;

  // * - умножение
  // / - деление
  // % - остаток от деления (взятие по модулю)
  cout << "a + b = " << (a + b) << endl; // В C++ используется endl вместо "\n"
  cout << "a - b = " << (a - b) << endl;
  cout << "a * b = " << (a * b) << endl;
  cout << "a / b = " << (a / b) << endl;
  cout << "a % b = " << (a % b) << endl;


  // Пытаемся вызвать несуществующую команду операционной системы
  system("NetTakoiComandy");
  system("pause");
```

.\02_operators_chain\main.cpp
Оператор присваивания. Операторы и их приоритеты. Скобки
--------------------------------------------------------
Операции отношения: (<, <=, >, >=, ==, !=). Логические операции (&& и ||).
Цепочки операторов
------------------
Объявляем 2 переменные
целого типа
``` cpp
  int a = 3, b = 5;
```

Сокращённая форма оператора присваивания
Сокращённые операторы (+=, -=, *=, /=, %=, ++, --).
Инкремент
Декремент
Пенять значение 2-х переменных местами
без использования 3-ей (промежуточной)
a = &p++ + (--a + ++b)
c = {     1, 2,
3, 5, 7, 10,
7, 20, 2, 3,
7, 20    }
.\02_square\main.cpp
.\03_HelloWorld_Cpp\main.cpp
Виды памяти
-----------
* Статическая
* Стек: локальные переменные + вызов функций / методов
* Динамическая: new / delete, [m/c]alloc / free
*Статическая* память: глобальные переменные
``` cpp
int staticArray[1000];
int staticConsts[3] = {3, 4, 5};
```

Переменные с модификатором static.
Переменная *count* видна только внутри функции ff,
но при этом сохраняет своё значение между вызовами ff
``` cpp
int ff() {
  static int count = 0;
}
```

*Стек*: локальные переменные + вызов функций / методов
``` cpp
int f() {
  int x = 10; // в стеке
  f();
}
```

*Динамическая*: new / delete, [m/c]alloc / free
``` cpp

```

.\03_HelloWorld_Cpp\test.cpp
.\03_OnlyC\main.c
Объявление переменных. Основные типы данных
-------------------------------------------
Целочисленные (модификаторы знаковый/беззнаковый)
``` cpp
  int N = 10;
  int a, b;
  signed int = -5;
  unsigned int = 10;
  short ss = 3;
```

Ввод и вывод данных (консоль) в C
---------------------------------
Печать значения. %d - целое число
``` cpp
  printf("N = %d\n", N);
  scanf("%d %d", &a, &b);
  /* a -> значение */
  printf("a + b = %d\n", a + b);

  a = b * b;
  printf("a = %d\n", a);
```

Ввод и вывод из текстового файла
.\03_PostfixPrefixIncrement\main.cpp
Префиксная и постфиксная форма инкремента и декремента
int i = 3;
for(int i = 2; i < 10; i++)
cout << i << endl;
cout << i << endl;
.\03_names_format\main.cpp
Стиль оформления исходных тестов программ. Отступы, "лесенка", пробелы
----------------------------------------------------------------------
Вложенные конструкции всегда с отступом
``` cpp
void f() {
  int x = 1;
}

int main() {
  int a;
  {
    a++;
    int b;
    {
      b++;
      int c;
    }
  }
  cnt = 0;

  for(int i = 0; i < 10; ++i) {
    int x = 1;

    for(int j = 0; j < 10; ++j)
      cnt++;
  }


  return 0;
}
```

Преимущества и недостатки автоматического форматирования исходного текста программы
-----------------------------------------------------------------------------------
.\03_signed_usigned\main.cpp
cout << "ul = " << (signed long)ul << endl;
.\03_types\main.cpp
Объявление переменных. Основные типы данных: целочисленные (модификаторы знаковый/беззнаковый), вещественные (с плавающей точкой), логический тип, символы, строки
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Примитивные типы данных в C/C++
limits.h - заголовочный файл стандартной библиотеки общего назначения,
который включает определения характеристик общих типов переменных.
ЦЕЛЫЕ ЧИСЛА
-----------
Дополнительный код:
* 000 - 0
* 001 - 1
* 010 - 2
* 011 - 3
* 100 - 4  @ -4
* 101 - 5  @ -3
* 110 - 6  @ -2
* 111 - 7  @ -1 => -1
*   1 + -1 = 0
* 01 + 11 = 100
https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4_(%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%B0)
*char* 1 байт = 8 бит
U - unsigned - беззнаковые типы
S - signed - знаковые типы
2 байта = 16 бит
4 байта = 32 бита
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
Двоичных констант в C/C++ нет
4 байта для 32-битной и 8 байт для 64-битной
Microsoft C++
В GNU C++ для совместимости:
#define __int64 long long
Вещественные/действительные (с плавающей точкой)
------------------------------------------------
=== Действительные числа ===
Логический тип, символы, строки
-------------------------------
setlocale(LC_ALL, "Russian");
.\04_types_demo\main.cpp
Операции
--------
.\05_c_cpp.md
﻿Отличия C и C++ (ссылки, в приведении типов, перегрузка функций)
================================================================

Ссылки:
-------
* После создания ссылки ее нельзя перевести на другой объект; в таких случаях говорят, не может быть **переопределена**. Это часто делают с указателями.
* Ссылки не могут быть null (т.е.указывать в никуда), тогда как указатели - могут; каждая ссылка ссылается на некий объект, вне зависимости от его корректности.
* Ссылки не могут быть неинициализированными. Так как невозможно переинициализировать ссылку, она должна быть инициализирована сразу после создания.
В частности, локальные и глобальные переменные должны быть проинициализированы там же,
где они определены, а ссылки, которые являются данными-членами сущностей класса,
должны быть инициализированы в списке инициализатора конструктора класса.

``` cpp
int& k; // компилятор выдаст сообщение: ошибка: 'k' declared as reference but not initialized
        // ('k' объявлена как ссылка, но не инициализирована)
```

.\05_floats\main.cpp
Пример на погрешность вычислений в вещественных числах
fabs - взять по модулю
if(a + b == c) {
.\06_C_printf\main.c
Вывод ещё более длинного целого :)
signed / unsigned
знаковый / беззнаковый
'long long long' is too long for GCC
long long long lll = 912345678900L;
printf("%llld %d\n", lll, sizeof(lll));
2 знака после запятой (точки)
.\06_C_printf\test.cpp
.\06_IncDec\main.cpp
.\07_Swap\main.cpp
a = a ^ b
b = b ^ a
a = a ^ b
.\07_if\main.cpp
Условный оператор if
--------------------
Синтаксис:
``` cpp
  if(/*Условие*/ 1 )
    cout << "Если условие истинно!" << endl;
  else
    cout << "Если условие ложно!" << endl;

```

Всегда ложное условие
``` cpp
  if(0) {
    // Сюда мы никогда не попадём
  }

```

Всегда истинное условие
``` cpp
  if(1) {
    // Сюда мы попадём всегда
  }

```

Операции сравнения:
-------------------
* >= - больше или равно
* <= - меньше или равно
* != не равно
* !a
* > - больше
* < - меньше
* && - логическое И
* || - логическое ИЛИ
.\08_if\main.cpp
Условный оператор if
&& - логическое И
|| - логическое ИЛИ
! - логическое НЕ
Тернарный оператор - альтернатива if
.\09_if_error\main.cpp
Самая характерная (распространённая)
ошибка при применении if
.\10_min_if\main.cpp
Минимум из двух чисел при помощи оператора if
.\11_function_visibility\main.c
Функции и области видимости
#include <conio.h> // функция getch()
Функции
Глобальная переменная
getch(); // Ожидаёт нажатие клавиши и возвращает её ASCII код
.\12_CFunc\main.c
Объявление и вызов функций
fabs, abs
.\13_CppFunc\main.cpp
.\14_while\main.cpp
Цикл while, структуры
---------------------
Вывод на русском языке
Структура для хранения адреса
В стиле C:
В стиле C++
.\15_do_while\main.cpp
Цикл с постусловием
-------------------
Вывод числа N в двоичной системе счисления
Двоичные цифры в обратном порядке
``` cpp
  int N = 254;
  cout << "N = " << N << " = (inverse binary) = ";

  do {
    cout << N % 2;
    N /= 2;
  } while(N > 0);

  cout << endl;
```

.\16_do_while\main.cpp
Win1251 и в исходном тексте и в консоли
Цикл с постусловием
repeat until()
Тело цикла
.\17_for\main.cpp
Применение цикла for
b < 10 - игнорируется
.\19_const_c\main.c
Константа без типа имеет тип int в C (но не в C++)
.\20_for_MulTable_homework\main.cpp
Таблица умножения с выравниванием столбцов
.\21_struct\main.cpp
Структуры C и работа с динамической памятью
Вывод на русском языке
Структура для хранения адреса
В стиле C:
В стиле C++
.\22_InputIntegers\main.cpp
Ввод целых чисел
----------------
cout - объект C++
printf - функция C
.\24_ternary_C\main.c
Демонстрация вызова макроса
.\25_namespace\main.cpp
Библиотека для работы с видео
Библиотека для работы со звуком
using namespace std;
using namespace audio;
using namespace video;
i = 12;
.\30_quadratic_equation\main.cpp
Решение квадратного уравнения - разбор домашнего задания
----------------------------------------------------------
Задание:
Написать программу, которое решает квадратное уравнение.
Пользователь вводит (с клавиатуры) три действительных
коэффициента a, b, c.
Программа выводит все решения уравнения (два, одно),
"решений нет", если их нет или "бесконечно много решений",
если подходит любое значение x (a = 0, b = 0, c = 0).
Обработать все варианты исходных данных.
Точность сравнения с нулём
Функция: решение квадратного уравнения
a,b,c - коэффициенты уравнения
результат функция выводит на экран
Если все три коэффициента нули, то x - любой
0x^2 + 0x + 0 = 0
0*x^2 + 0*x + не_ноль = 0 - решений нет
Линейное уравнение
0*x^2 + b*x + c = 0
Проверка решения
Вычисление дискриминанта
Проверяем полученный x
Комплексные корни
D > 0 - 2 действительных корня
Проверяем полученные решения
Основная программа - тестирование
Коэффициенты квадратного уравнения
Вызов функции решения квадратного уравнения
.\50_russian_console_input_output\main.c
long double ldbl = 1.22;
printf("%L\n", ldbl);
.\90_homework_printf\main.cpp
for(инициализация; условие_продолжения;
шаг_после_тела_цикла)
0   1   2   3   4   5   6   7   8   9
ijk..
.\96_test_qt\main.cpp
.\96_test_qt\mainwindow.cpp
.\96_test_qt\mainwindow.h
.\97_OpenGL\main.c
Пример OpenGL приложения на C
.\98_binary_constants_by_macros\main.cpp
Двоичные константы в C при помощи макросов и побитовых операций
Удобная функция для отладки
Демонстрационные примеры
B8(01010101) = 85
B16(10101010,01010101) = 43605
B32(10000000,11111111,10101010,01010101) = 2164238933
.\99_binary_constants\main.cpp
Представление двоичных констант в C++
-------------------------------------
Рекурсивный "шаблон"
``` cpp
template<long long N>
struct bin {
  enum {
    value = (N % 8) + (bin < N / 8 >::value << 1)
  };
};

template<>
struct bin<0> {
  enum { value = 0 };
};

// Macro-processing glue: force the number to be octal to both
// end the recursion chain and make posible more digits
#define binary(n) bin<0##n>::value

// Проверка работы макроса
int main() {
  cout << bin<01000>::value << endl;
  cout << bin<1000>::value << endl;
  cout << binary(01000) << endl;
  cout << binary(1000) << endl;
  return 0;
}
```

.\HomeWork\main.cpp
Решение квадратного уравнения
-------------------------------
Задание:
Написать программу, которое решает квадратное уравнение.
Пользователь вводит (с клавиатуры) три действительных коэффициента a, b, c.
Программа выводит все решения уравнения (два, одно), "решений нет",
если их нет или "бесконечно много решений", если подходит любое значение x (a = 0, b = 0, c = 0).
Обработать все варианты исходных данных.
``` cpp
void solve_equation(double a, double b, double c) {
  // TODO: реализовать
}
```

``` cpp
  // Коэффициенты квадратного уравнения
  double a, b, c;
  // a*x^2 + b*x + c = 0
  cout << "a = ";
  cin >> a;
  cout << "b = ";
  cin >> b;
  cout << "c = ";
  cin >> c;
  cout << endl;

  // Вызов функции решения квадратного уравнения
  solve_equation(a, b, c);
```

.\OpenGL_Test\main.c
.\main.cpp
Комментарии C++
Подключение библиотеки
