.\000_intro.md
﻿Введение в Qt, Qt Creator, QtCore, QtGui, отладка
=================================================

Ссылки для скачивания
---------------------
* Qt Creator: http://qt-project.org/downloads
* http://www.qt.io/download-open-source/

При установке снимите галочку с **msvc 2013 ..** и поставьте на **MinGW 4.9.1**.

QT - история
------------

Первый выход в свет библиотеки Qt состоялся в мае 1995 года.
Первоначально она разрабатывалась Хаавардом Нордом (главный управляющий Trolltech) и Эриком Чамбенгом (президент компании Trolltech).
Хаавард и Эрик встретились в стенах Норвежского Технологического Института, в городе Тронхейме, где они получали высшее образование.

В 1991 году Хаавард написал первые несколько классов, из которых потом и появилась Qt.
Эрик занялся разработкой общего дизайна библиотеки.
На следующий год Эрику пришла в голову идея реализации "сигналов и слотов" - простой но очень мощной парадигмы программирования графического интерфейса.
Хаавард подхватил идею и воплотил ее в код.
К 1993 году они завершили разработку первого графического ядра и приступили к созданию визуальных компонентов (widgets).
В конце года Хаавард предложил Эрику открыть совместное дело и выпустить "лучшую в мире библиотеку реализации графического интерфейса на C++".

**Сигнал** генерируется когда происходит определенное событие.

**Слот** - функция (обработчик), которая вызывается в ответ на определенный сигнал.

В качестве префикса в именах классов был выбран символ "Q", поскольку Хааварду очень нравилось как он выглядел в Emacs.
Символ "t" был выбран потому, что с него начиналось слово "toolkit", по аналогии с "Xt" -- "X toolkit".
Компания была зарегистрирована 4 марта 1994 года под названием "Quasar Technologies", которое затем было преобразовано в "Troll Tech", а затем и в "Trolltech".

В апреле 1997 года вышла Qt 1.2.

В 2001 году вышла Qt 3.

Летом 2005 года была выпущена Qt 4.0.
Имея около 500 классов и более 9000 функций, Qt 4 оказалась больше и богаче любой предыдущей версии;
она была разбита на несколько библиотек, чтобы разработчики могли использовать только нужные им части Qt.
Версия Qt 4 представляет собой большой шаг вперёд по сравнению с предыдущими версиями;
она содержит полностью новый набор эффективных и простых в применении классов-контейнеров, усовершенствованную функциональность архитекторы модель/представление,
быстрый и гибкий фреймфорк графики 2D и мощные классы для просмотра и редактирования текста в кодировке Unicode,
не говоря уже о тысячах небольших улучшений по всему спектру классов Qt.
Qt 4 является первой версией Qt, доступной на всех поддерживаемых платформах как для коммерческой разработки, так и для разработки с открытым исходным кодом.

2012 год - выход Qt 5.0.
Главные изменения в Qt5 связаны с модульностью Qt и активным переходом на декларативное описание интерфейса (Qt Quick).
Это не значит, что Qt перепишут на JavaScript,
просто C++ будет использоваться для написания критичных ко времени выполнения или сложных вещей.
Сохраняется и базовая обратная совместимость: в Qt 5 вошли почти все компоненты Qt 4, кроме устаревших,
большинство модулей из Qt Mobility (теперь это уже не отдельный продукт) и некоторые экспериментальные разработки.

Установка и запуск Qt Creator. Qt Designer
------------------------------------------

Создание простейшего приложения. Сигналы и слоты. Обработка событий
-------------------------------------------------------------------

Проектирование пользовательского интерфейса с учётом требований эргономичности (компоненты, события, сигналы, слоты в Qt)
-------------------------------------------------------------------------------------------------------------------------


.\00_FirstQtApp\README.md
﻿Первое приложение Qt
====================
* Запускаем Qt Creator
* Создаём главную форму
* Добавляем виджеты
* Используем сигналы и слоты

.\00_FirstQtApp\debug\moc_dialog.cpp
content:
.\00_FirstQtApp\debug\moc_mainwindow.cpp
content:
slots: name, argc, parameters, tag, flags
slots: parameters
.\00_FirstQtApp\dialog.cpp
.\00_FirstQtApp\dialog.h
.\00_FirstQtApp\main.cpp
argc - количество аргументов
argv - параметры командной строки
Обработка сигналов
Связь сигнал -> слот
Создаём основное окно
Показываем основное окно
Запуск основного цикла обработки событий
.\00_FirstQtApp\mainwindow.cpp
Слот - реализуется как обычный метод
ui - Ui::MainWindow *ui;
Указатель на сгенерированный
по *.ui файлу класс Ui::MainWindow
line1 - узказатель на виджет
Чтобы получить текст мы вызываем
метод text()
который возвращает QString
Свойство называется так:
имяСвойства
Чтобы получить значение вызываем метод:
имяСвойства()
Чтобы поменять вызываем метод:
setИмяСвойства(Новое_значение_свойства)
.\00_FirstQtApp\mainwindow.h
parent - объект при уничтожении которого
должен быть уничтожен и этот объект
Обычно основное (главное) окно программы
Слоты - методы-обработчики сигналов
.\00_FirstQtApp\release\moc_dialog.cpp
content:
.\00_FirstQtApp\release\moc_mainwindow.cpp
content:
slots: name, argc, parameters, tag, flags
slots: parameters
.\00_FirstQtApp\ui_dialog.h
.\00_FirstQtApp\ui_mainwindow.h
.\01_QtGUI_Properties\README.md
﻿Изменение свойств объектов по событиям
======================================


.\01_QtGUI_Properties\main.cpp
.\01_QtGUI_Properties\mainwindow.cpp
Получаем у кнопки её шрифт
ui->pushButton->setText("Привет");
.\01_QtGUI_Properties\mainwindow.h
.\02_Qt_console_debug\README.md
Отладка Qt приложений
=====================

.\02_Qt_console_debug\main.cpp
потому что в строке символ 0 - окончание строки
Создает копии динамических переменных и ресурсов
.\02_map_example\main.cpp
map<ключ, значение>
m[ключ] = значение;
...
.\02_map_example\юю\main.cpp
.\02_map_example\юю\mainwindow.cpp
.\02_map_example\юю\mainwindow.h
.\02_map_example_1\main.cpp
.\02_map_example_1\mainwindow.cpp
.\02_map_example_1\mainwindow.h
.\02_map_example_2\main.cpp
.\03_QtGUI\main.cpp
.\03_QtGUI\mainwindow.cpp
.\03_QtGUI\mainwindow.h
.\03_map_example\main.cpp
Конец слова
Выделяем слово
Переводим слово
.\04_QtCalc\CalcStates.h
продолжаем вводить число
бинарную операцию
.\04_QtCalc\main.cpp
.\04_QtCalc\mainwindow.cpp
Очищаем дисплей
UTF-8
(QPushButton *)QObject::sender() -
отправитель текущего сигнала
Удаляем из s все лидирующие нули
Дописываем цифру на экран
Изменяем состояние всех кнопок
Можно нажимать ".",
только если на дисплее точек ещё нет
Складываем содержимое экрана и память
Запоминаем содержимое экрана
.\04_QtCalc\mainwindow.h
Когда нажимаем на цифровую кнопку
вызывается этот слот
.\05_Exceptions\main.cpp
throw 2;
qDebug() << "Error: " << s;
.\10_Qt_XO\cellbutton.cpp
Параметры:
text - текст на кнопке
parent - окно, в котором кнопка будет расположена
для корретного удаления кнопки
row - строка, col - столбец на поле
game - ссылка на игру
this->game = &game;
Если на кнопке написан крестик или нолик,
то нажимать на неё нельзя
При нажатии на клетку
Выводим координаты нажатия для отладки
Делаем ход => получаем результат
для данной клетки
Больше не можем нажимать на эту клетку поля
(эту кнопку)
.\10_Qt_XO\cellbutton.h
Одна клетка поля, наследник стандартной Qt-кнопки
Параметры:
text - текст на кнопке
parent - окно, в котором кнопка будет расположена
для корретного удаления кнопки
row - строка, col - столбец на поле
game - ссылка на игру
Нажатие на кнопку
.\10_Qt_XO\game.cpp
При старте программы сразу начинается новая игра
Новая игра
Первыми ходят всегда крестики
Заполняем поле пустыми клетками, без крестиков и ноликов
Совершаем ход

QMessageBox::information(NULL, "Ход",
QString("Ход в клетку: (%1; %2)")
.arg(row+1).arg(col+1));
Три крестика или три нолика
Если не все элементы равны => не подходит
Кто-то выйграл :)
== Проверяем диагонали ==
Основная диагональ
Дополнительная диагональ
(0,0) (0,1) [0,2]
(1,0) [1,1] (1,2)
[2,0] (2,1) (2,2)
Вертикальные и горизонтальные линии
Вертикальная линия
копируем в a i-ый столбец
Горизонтальная линия
Проверяем что крестики или нолики выйграли
и выходим
Ничья = не осталось пустых клеток
Сохранение игры
Сохраняем данные
Загрузка (чтение) сохранённой игры из файла
Читаем данные
Считываем размер карты
Проверяем количество крестиков и ноликов
.\10_Qt_XO\game.h
Состояние игры
Все что происодит на поле и логика игрового мира
Ходы, выйгрыш/проигрыш
Игровое поле
Проверка выйгрыша
проверяется одна строка
один столбец или одна диагональ
Конструктор
Новая игра без пересоздания объекта
Получаем строку, соответствующую состоянию игры
Совершаем ход, возвращает строку для клетки на форме
Проверяем на окончание игры
Сохранение игры
Загрузка игры
Состояние ячейки
.\10_Qt_XO\gamesettings.cpp
Записываем текущий размер поля
Берём новое значение размера поля
из интерфейса и записываем как MapSize
.\10_Qt_XO\gamesettings.h
.\10_Qt_XO\main.cpp
Мы можем создать второе такое же окно
MainWindow w2;
w2.show();
Обработка событий - основной цикл работы программы
.\10_Qt_XO\mainwindow.cpp
Скрываем кнопку с прототипом
Задаём размер массиву кнопок
Заполним весь массив кнопок поля NULL
Начало игры
Выход из программы
ui->lineEdit_1->setText(QString("1"));
ui->lineEdit_2->setText(QString("2"));
После изменения состояния игры
Подстраиваем размер, т.к. эта метка не в Layout
Создаём массив MapSize на MapSize из QPushButton
Шрифт как в прототипе
Задаём размеры и положение кнопки
critical(QWidget * parent, const QString & title,
const QString & text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)
Вызываем окно настройки размера поля
После изменения размера поля
перестартуем игру
.\10_Qt_XO\mainwindow.h
Новый слот
.\10_Qt_XO\map_size.h
Размер поля игры
const int MapSize = 3;
.\Airports_qt\main.cpp
freopen("log.txt", "w", stdout);
return -1;
.\HomeWork_1\main.cpp
.\HomeWork_1\mainwindow.cpp
TODO: реализовать перемещение
ui->textEdit->geometry().translate(0, 10);
TODO: реализовать перемещение
TODO: реализовать перемещение
TODO: реализовать перемещение
.\HomeWork_1\mainwindow.h
.\QTableViewDemo\main.cpp
.\QTableViewDemo\mainwindow.cpp
Модель данных (массив 9 на 9 элементов)
В таблице в интерфейсе будет показываться именно
эта модель
Добавляем таблицу чисел
.\QTableViewDemo\mainwindow.h
Модель: контейнер (массив) для ячеек таблицы
.\QtCalc\README.md
Добавить "-" и "*"

.\QtCalc\main.cpp
.\QtCalc\mainwindow.cpp
Пока нет операции
Сейчас будем вводить новое число
Это состояние в самом начале работы,
а также после каждой операции
xbutton_clicked - слот, который может принимать
сигналы от разных кнопок: '1','2'...'9','0'
Если сейчас вводим новое число
то все "старые" цифры с дисплея убираем
Узнаём, от какой кнопки пришёл сигнал
Добавляем новую цифру на дисплей
Узнаём, от какой кнопки пришёл сигнал
1. Получаем текст с кнопки
2. Переводим из QString (UTF-8) в обычную C-строку
3. Берём только первый символ
Выводим полученную с кнопки операцию в консоль
Получаем второй аргумент
Вычисляем результат
операция не реализована
Показываем целое число в интерфейсе
Добавляем точку
try{
} catch(){
qDebug() << s << " - incorrect double";
}
.\QtCalc\mainwindow.h
Последняя операция
Запоминаем число набранное на калькуляторе
Сейчас будем вводить новое число
.\QtConsoleExample\main.cpp
Поиск минимума в двухмерном массиве
Инициализируем максимальным числом для типа int
.\QtConsole\main.cpp
Консольное приложение на Qt для
вычисления факториала
.\QtContainers\main.cpp
.\QtContainers\mainwindow.cpp
.\QtContainers\mainwindow.h
.\QtDLLExample\qtdllexample.cpp
.\QtDLLExample\qtdllexample.h
.\QtDLLExample\qtdllexample_global.h
.\QtDemo\main.cpp
.\QtDemo\mainwindow.cpp
Получаем 2 строки из интерфейса
Конкатенация строк
Передаём результат в интерфейс
Генерация случайной строки
Любая буква английского алфавита
Генерируем первую строку
Генерируем вторую строку
.\QtDemo\mainwindow.h
Генерация случайной строки
.\QtFirstApplication\main.cpp
.\QtFirstApplication\mainwindow.cpp
Получаем строчку из первого (верхнего) поля
Получаем строчку из второго поля
Складываем числа
Результат в строчку
..используем строку форматирования..
Помещаем результат обратно в интерфейс
.\QtFirstApplication\mainwindow.h
.\QtGame\main.cpp
.\QtGame\mainwindow.cpp
Получаем текущее расположение кнопки
Изменяем координаты кнопки
Передаём изменённые координаты обратно в интерфейс
Получаем текущее расположение кнопки
Изменяем координаты кнопки
Передаём изменённые координаты обратно в интерфейс
Получаем текущее расположение кнопки
Изменяем координаты кнопки
Передаём изменённые координаты обратно в интерфейс
Получаем текущее расположение кнопки
Изменяем координаты кнопки
Передаём изменённые координаты обратно в интерфейс
.\QtGame\mainwindow.h
.\QtInterface\main.cpp
.\QtInterface\mainwindow.cpp
.\QtInterface\mainwindow.h
.\QtNewDemo\demowindow.cpp
.\QtNewDemo\demowindow.h
.\QtNewDemo\main.cpp
Создаём Qt-приложение
Создаём основное окно
Показываем его
Обработка событий приложения
.\QtNewDemo\mainwindow.cpp
Получаем 2 строки из интерфейса
Соединяем строки
Результат в интерфейс
.\QtNewDemo\mainwindow.h
Главное окно программы
Текущее окно приложения
.\QtNewDemo\secondwindow.cpp
.\QtNewDemo\secondwindow.h
.\QtSlotsSignals\README.md
