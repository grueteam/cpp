.\000_intro.md
Стиль оформления кода программы
-------------------------------

*Зачем?*

Одним из важнейших факторов, влияющих на способность программы к развитию, является лёгкость её *понимания*.
Одним из существенных факторов понимаемости программы, в свою очередь, является информативность исходного текста.
Если исходный текст трудно читать (он написан без соблюдения определенного стиля и системы и представляет собой
"мешанину" операторов и знаков препинания),
то вносить изменения в него очень сложно даже автору.

Рассмотрим ряд требований и рекомендаций, позволяющих выработать хороший стиль оформления программ, повышающий ее информативность.

Типичные рекомендации
---------------------

*1. Допускаются любые нарушения рекомендаций, если это улучшает читаемость*

Основная цель рекомендаций - улучшение читаемости и, следовательно, ясности и лёгкости поддержки,
а также общего качества кода.
Невозможно дать рекомендации на все случаи жизни, поэтому программист должен мыслить гибко.

Тернарный оператор - (усл) ? T : F
----------------------------------

*Тернарная условная операция* (лат. ternarius - "тройной") (обычно записывается как ?:) - во многих языках программирования операция,
возвращающая свой второй или третий операнд в зависимости от значения логического выражения, заданного первым операндом.

Массивы: одномерные, многомерные
--------------------------------

Условный оператор if else
-------------------------

Множественный выбор switch
--------------------------

Циклы с предусловием и постусловием: while, do while
----------------------------------------------------

Цикл for
--------

Записи (struct - структуры). typedef. Записи с вариантами (union)
-----------------------------------------------------------------

Операторы break, continue
-------------------------

Модули: заголовочный файл (header), основной файл (.c и .cpp, .h и .hpp)
------------------------------------------------------------------------


Домашнее задание
----------------
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.

Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1

Указатели, работа с памятью
===========================

Типы памяти: статическая, динамическая (куча), стек
---------------------------------------------------

Выделение и освобождение динамической памяти (malloc / free)
------------------------------------------------------------

Ссылки и указатели в C++: общее и различия
------------------------------------------

Операторы new и delete
----------------------

Утечки памяти и методы борьбы с ними
------------------------------------

Отличия C и C++ (ссылки, в приведении типов, перегрузка функций)
----------------------------------------------------------------

Использование динамической памяти на примере реализации структур данных: список, стек, очередь и "дерево"
---------------------------------------------------------------------------------------------------------


.\00_HomeWork\main.cpp
Win1251 и в исходном тексте и в консоли
Ввод коэффициентов уравнения
Вычисление дискриминанта
Вычисление и вывод ответа(ов) x
.\01_min_cpp\main.cpp
В C++ перегрузка функций разрешена
С точки зрения С++ можно переопределять функции
(т.е. создавать несколько функций с одинаковым именем,
отличающиеся только типами аргументов).
В обычном С этого делать нельзя
Поэтому в C есть функции:
abs - модуль для целых чисел и
fabs - модуль для действительных чисел
.\01_min_ternary\main.c
Универсальная функция min на C
Макрос с использованием тернарного оператора
Нужен префикс f:  math.h -> abs/fabs
.\01_operations_priority\main.cpp
.\01_ternary\main.cpp
Тернарный оператор слева от присваивания
.\02_ternary\main.cpp
Тернарный оператор
Может находиться слева от оператора присваивания
Вложенные тернарные операторы
Если число делится на 5 и не делится на 7, то прибавить 2
иначе 4
.\02_while\main.cpp
Выводим N в двоичной системе счисления
разряды в обратном порядке
...
.\03_for\main.cpp
#include <stdio.h> // C
.\03_switch\main.cpp
system("chcp(65001)");
N < 0 => ошибка
0 углов => пустота
1 угол => точка
2 угла => отрезок
3 угла => треугольник
4 угла => четырёхугольник
N >= 5 углов => N-угольник
Общая обработка для случаев N = 4,5
cout << "N-угольник" << endl;
.\04_function_var_visibility\main.cpp
.\05_factorial\main.cpp
Итеративное вычисление факториала
Цикл от большего к меньшему
Итеративное вычисление факториала
Цикл от меньшего к большему
Рекурсивный способ вычисления факториала
Тестирование работы функции
cout << i << "! = " << res << endl;
.\06_var_reference\main.cpp
По ссылке
По указателю
.\07_arrays\main.cpp
Массивы
Одномерные
``` cpp
  int intArray[10];
  // int - тип элементов массива
  // intArray - название массива
  // 10 - количество элементов
  // Нумерация элементов: 0..9

  // Записываем 23 в первый элемент массива
  intArray[0] = 23;
  intArray[1] = 10; // Второй элемент массива

  cout << intArray[0] + intArray[1] << endl;

  // Увеличить каждый элемент массива на 10
  for(int i = 0; i < 10; ++i)
    intArray[i] += 10;

  // Поиск минимума в массиве
  int minValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] < minValue)
      minValue = intArray[i];

  // Поиск максимума в массиве
  int maxValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] > maxValue)
      maxValue = intArray[i];

```

.\08_array_sort\main.cpp
Пример массива для сортировки
Выводим массив
for(int i = 0; i < N; ++i)
cout << A[i] << " ";
cout << endl;
Задание: отсортировать массив
{-2, 10, 1, 5, 6, 11}
{-2, [ 1, 10, 5, 6, 11 ] }
{-2, 1, [5, 10, 6, 11 ] }
SWAP
int temp = A[i];
A[i] = A[i+1];
A[i+1] = temp;
A[i] ^= A[i+1] ^= A[i] ^= A[i+1];
-----
| 1 | 0
-----
| 3 | 1
-----
| 5 | 2
-----
| 6 | 3  <-- i
-----
| 7 | 4
-----
Снова вывести на экран
.\08_array_task\main.cpp
ЗАДАЧА: посчитать сумму.
Нумерация элементов массива с 0
Все элементы на чётных местах взять с "+"
Все элементы на нечётных местах с "-"
Чётные: 0, 2, 4, 6 и т.д.
Нечётные: 1, 3, 5...
Сумма равна 0
Если элемент нечётный i % 2 == 1
если чётный i % 2 == 0
result += (i % 2) ? -A[i] : A[i];
Суммируем только чётные
Суммируем только нечётные
1 - 3 -2 -4 + 2 -10 = -16
.\09_arrays\main.cpp
2D массив
статической памяти и сохраняют своё значение между вызовами
myArray[0] = 3
myArray[1] = 10
myArray[2] = 20
myArray[3] = 43
.\09_arrays_2D\main.cpp
Поиск минимума
Сумма всех элементов
.\10_CallsCount\main.cpp
.\10_struct_C\main.c
Вывод комплексного числа на экран
Comp res = {a.re + b.re, a.im + b.im};
.\10_struct_C_2\main.c
.\10_stuct_Cpp\main.cpp
.\11_StackSize\main.cpp
.\11_show_in_memory_presentation\main.cpp
.\11_struct_C_Point2D\main.c
Математические функции
typedef определение_типа название_типа;
typedef struct Point P;
Расстояние между двумя точками
.\11_struct_cpp\main.cpp
Математические функции
typedef определение_типа название_типа;
typedef struct Point P;
Расстояние между двумя точками
.\13_strings_buffer_oveflow\main.cpp
Переполнение строки символов
Смертный Грех программиста №1 - источник уязвимостей
Ввод с клавиатуры
Ввод из файла
Получение пакета из сети
.\15_howework\main.cpp
Стек
Добавить значение на вершину
TODO: реализовать
Забрать значение и вернуть
TODO: реализовать
.\16_FileLog_DebugExample\main.cpp
.\C_struct\main.c
Структуры в чистом C
cout << "(" << p.x << ";" << p.y << ") ";
.\HomeWork_1\README.md

.\HomeWork_1\main.cpp
Домашнее задание - структуры данных
Сумма
TODO: Реализовать
Разность
TODO: Реализовать
Скалярное произведение векторов
TODO: Реализовать
Тестирование
.\HomeWork_2\README.md

.\HomeWork_2\main.cpp
Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.
-----------------------
Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
N - число для разложения
m - максимальное слагаемое в сумме
Цифры
Количество
Окончание рекурсии
x - текущее слагаемое
Сумма уменьшилась на x
Максимальное слагаемое - x
Убираем последнее слагаемое
Вводим число N
Вывод разложения на слагаемые
.\HomeWork_2_dynmemory\main.cpp
Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.
-----------------------
Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
Цифры
N - число для разложения
m - максимальное слагаемое в сумме
K - количество цифр
Окончание рекурсии
x - текущее слагаемое
Сумма уменьшилась на x
Максимальное слагаемое - x
Вводим число N
Цифры
new int[N]; - возвращает указатель на int
Вывод разложения на слагаемые
A = new type[SIZE]    delete[] A  -- создание и удаление массива
в динамической памяти
A = new type;  delete A; -- создание и удаление одиночного
объекта
.\Memory\main.cpp
Статическая память
int veryBigArray[SIZE];
int *a,b;
int *a; int b;
int *a,*b; - теперь оба указателя
a = (int *)12312;
.\OrAndExample\main.cpp
.\RussianInput\main.cpp
.\RussianLocale\main.cpp
SetConsoleOutputCP(65001);
SetConsoleCP(65001);
setlocale(LC_ALL, "Russian.UTF-8");
.\cpp_dynamic\main.cpp
Заводим массив в динамической памяти
.\factorial\main.cpp
Без: using namespace std;
Win1251 и в исходном тексте и в консоли
.\function_declaration\main.cpp
Функции
...
using namespace my;
.\lesson2_eq\main.cpp
a^=b^=a^=b; // XOR - исключающее или
int g = f++ + f++ + f++;
g = f++;
cout << "a = " << a << " b = " << b << endl;
.\malloc_free\main.c
Память не отведена
Освобождаем динамическую память
чуть постарше 1
Два порядка байтов:
* Big-endian - старший байт в конце (IBM, майнфреймы, Sun Sparc и т.д.)
* Little-endian - младший байт первый (Intel и совместимые)
Little - основное преимущество - можно начинать складывать младшие байты
не дожидаясь пока старшие "прийдут" по шине
.\min_array\main.cpp
Поиск минимума в массиве
Пробежим по остальному массиву
каждый раз добавляя по одному элементу
и если он меньше текущего минимума
обновим минимум
Пробежим по остальному массиву
каждый раз добавляя по одному элементу
и если он меньше текущего минимума
обновим минимум
Индексы: 0  1  2  3
Вызов функции, ожидаем на выходе 4
.\overload_c\main.c
Универсальный максимум в стиле "C"
.\pointers\main.cpp
Исходное значение не меняется
Передаём ссылку -> меняем исходное значение
Передаём указатель -> меняем исходное значение
.\pointers\pointers2\main.cpp
Пример на ссылки и указатели
i - указатель, т.е. это
переменная содержащая адрес
i = &c;
.\references\main.cpp
Ссылки в C++
В с теперь будет адрес d
example1();
example3();
.\stack\main.cpp
Конструктор
- называется как класс
- нет возвращаемого значения
- параметры как у обычных методов
Деструктор - очистка памяти
Поместить на вершину стека
Создали новый элемент стека с новым значением
"Подвешиваем" root к новому элементу
Делаем новый элемент первым в списке
Получить значение с вершины стека
Получаем верхний элемент
Получаем значение верхнего элемента
Переставим корень списка на след. элемент
Очистим память
Вернём значение
Показать все элементы
Д.з. однонаправленный список
.\switch\main.cpp
Win1251 и в исходном тексте и в консоли
system("chcp 65001");
freopen()
.\union\main.cpp
typedef Определение_типа Имя_нового_типа;
Число:    01101110  00001101
Ном.бита: 76543210         1
.\union_2\main.cpp
