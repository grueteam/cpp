.\000_intro.md

Тернарный оператор - (усл) ? T : F
----------------------------------

*Тернарная условная операция* (лат. ternarius - "тройной") (обычно записывается как ?:) - во многих языках программирования операция,
возвращающая свой второй или третий операнд в зависимости от значения логического выражения, заданного первым операндом.

Массивы: одномерные, многомерные
--------------------------------

Условный оператор if else
-------------------------

Множественный выбор switch
--------------------------

Циклы с предусловием и постусловием: while, do while
----------------------------------------------------

Цикл for
--------

Записи (struct - структуры). typedef. Записи с вариантами (union)
-----------------------------------------------------------------

Операторы break, continue
-------------------------

Модули: заголовочный файл (header), основной файл (.c и .cpp, .h и .hpp)
------------------------------------------------------------------------


Домашнее задание
----------------
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.

Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1

Указатели, работа с памятью
===========================

Типы памяти: статическая, динамическая (куча), стек
---------------------------------------------------

Выделение и освобождение динамической памяти (malloc / free)
------------------------------------------------------------

Ссылки и указатели в C++: общее и различия
------------------------------------------

Операторы new и delete
----------------------

Утечки памяти и методы борьбы с ними
------------------------------------

Отличия C и C++ (ссылки, в приведении типов, перегрузка функций)
----------------------------------------------------------------

Использование динамической памяти на примере реализации структур данных: список, стек, очередь и "дерево"
---------------------------------------------------------------------------------------------------------


.\00_HW_done\main.cpp
Решение квадратного уравнения - разбор домашнего задания
----------------------------------------------------------
Задание:
Написать программу, которое решает квадратное уравнение.
Пользователь вводит (с клавиатуры) три действительных
коэффициента a, b, c.
Программа выводит все решения уравнения (два, одно),
"решений нет", если их нет или "бесконечно много решений",
если подходит любое значение x (a = 0, b = 0, c = 0).
Обработать все варианты исходных данных.
a*x^2 + b*x + c = 0
#ifdef DEBUG
#else
#define SHOW(x)
#endif // DEBUG
``` cpp
// Точность сравнения с нулём
const double EPS = 1e-10;
```

Функция: решение квадратного уравнения
a,b,c - коэффициенты уравнения
результат функция выводит на экран
``` cpp
void solve_equation(double a, double b, double c) {
  if(fabs(a) < EPS) {
    if(fabs(b) < EPS) {
      if(fabs(c) < EPS) {
        // Если все три коэффициента нули, то x - любой
        // 0x^2 + 0x + 0 = 0
        cout << "x - any number" << endl;
        return;
      }

      // 0*x^2 + 0*x + не_ноль = 0 - решений нет
      cout << "no solutions" << endl;
      return;
    }

    // Линейное уравнение
    // 0*x^2 + b*x + c = 0
    double x = -c / b;
    cout << "x = " << x << endl;
    // Проверка решения
    cout << "0*x^2 + b*x + c = " << 0 * pow(x, 2) + b* x + c << endl;
    return;
  }

  // Вычисление дискриминанта
  double D = b * b - 4 * a * c;

  if((fabs(D) < EPS) && (D != 0)) {
    SHOW(a)
    SHOW(b)
    SHOW(c)
    cout << "FIND IT! :)" << endl;
    system("pause");
  }

  cout << "D = " << D << endl;

  if(fabs(D) == EPS) {
    double x = -b / (2 * a);
    cout << "x = " << x << endl;
    // Проверяем полученный x
    cout << "f(x) = " << a* x* x + b* x + c << endl;
    return;
  }

  if(D < 0) {
    cout << "no solutions" << endl;
    // Комплексные корни
    double x_re = -b / (2 * a);
    double x1_im = +sqrt(-D) / (2 * a);
    double x2_im = -sqrt(-D) / (2 * a);
    cout << "x1 = " << x_re << " + " << x1_im << " i" << endl;
    cout << "x2 = " << x_re << " + " << x2_im << " i" << endl;
    return;
  }

  // D > 0 - 2 действительных корня
  double x1 = (-b + sqrt(D)) / (2 * a);
  double x2 = (-b - sqrt(D)) / (2 * a);
  cout << "x1 = " << x1 << "  x2 = " << x2 << endl;
  // Проверяем полученные решения
  cout << "f(x1) = " << a* x1* x1 + b* x1 + c << endl;
  cout << "f(x2) = " << a* x2* x2 + b* x2 + c << endl;
}
```

Основная программа - тестирование
``` cpp
  while(1) {
    // Коэффициенты квадратного уравнения
    double a = 2, b, c;
    SHOW(a)
    cout << "a = ";
    cin >> a;

    if(!cin.good()) {
      SHOW(a)
      break;
    }

    cout << "b = ";
    cin >> b;
    cout << "c = ";
    cin >> c;
    cout << endl;

    // Вызов функции решения квадратного уравнения
    solve_equation(a, b, c);
```

.\00_HomeWork\main.cpp
Win1251 и в исходном тексте и в консоли
Ввод коэффициентов уравнения
Вычисление дискриминанта
Вычисление и вывод ответа(ов) x
.\01_leff_const\main.cpp
Константы в if ставятся на первое место (до =)
``` cpp
const int a = 0;

int main() {
  int b = 0;

  if(a == b)
    cout << "a = b" << endl;
  else
    cout << "a != b" << endl;

  return 0;
}
```

.\01_min_cpp\main.cpp
В C++ перегрузка функций разрешена
С точки зрения С++ можно переопределять функции
(т.е. создавать несколько функций с одинаковым именем,
отличающиеся только типами аргументов).
В обычном С этого делать нельзя
Поэтому в C есть функции:
abs - модуль для целых чисел и
fabs - модуль для действительных чисел
.\01_min_ternary\main.c
Универсальная функция min на C
Макрос с использованием тернарного оператора
Нужен префикс f:  math.h -> abs/fabs
.\01_operations_priority\main.cpp
.\01_ternary\main.cpp
Тернарный оператор слева от присваивания
.\02_left_ternary\main.cpp
.\02_preproc_Cpp\main.cpp
Подключение библиотек
Препроцессор
Preprocessor
#include <aclui.h>
Основная программа
#ifdef sizeof(int) != 2
#error This code only for Linux
#endif // WIN32
Вывод на экран строчки
int c = 1+2;
cin >> c;
a = 10;
c += a += 2;
SHOW(c);
Обмен двух переменных значениями
без третьей переменной
Код возврата
.\02_ternary\main.cpp
Тернарный оператор
Может находиться слева от оператора присваивания
Вложенные тернарные операторы
Если число делится на 5 и не делится на 7, то прибавить 2
иначе 4
.\02_while\main.cpp
Выводим N в двоичной системе счисления
разряды в обратном порядке
...
.\03_for\main.cpp
#include <stdio.h> // C
.\03_switch\main.cpp
Множественный выбор switch
==========================
Вводим количество углов
``` cpp
  int N;
  cout << "Enter number of edges: ";
  cin >> N;
```

``` cpp
  switch(N) {
    case 1: // 1 угол => точка
      int i = 1, j = 10;

      for(int k = 0; k < 10; ++k) {

      }

      cout << "point" << endl; // Точка
      break;

    case 0: // 0 углов => пустота или круг
      cout << "emptiness / circle" << endl;
      break;

    case 2: // 2 угла => отрезок
      cout << "segment" << endl;
      break;

    case 3: // 3 угла => треугольник
      cout << "triangle" << endl;
      break;

    case 4: // 4 угла => четырёхугольник
    case 5:
      // Общая обработка для случаев N = 4,5
      cout << N << "th polygon" << endl;
      break;

    case -1:
      cout << "-1" << endl;

    case -2:
      cout << "-2" << endl;

    default:  // N < 0 => ошибка, N >= 5 углов => N-угольник
      cout << ((N < 0) ? "error" : "N-edged polygon") << endl;
      break;

    case -3:
      cout << "-3" << endl;
  }

```

.\04_function_var_visibility\main.cpp
.\04_static_big_than_stack\main.cpp
int veryBigArray[SIZE];
.\04_visibility\main.cpp
x[0]
.\05_factorial\main.cpp
Итеративное вычисление факториала
Цикл от большего к меньшему
Итеративное вычисление факториала
Цикл от меньшего к большему
Рекурсивный способ вычисления факториала
Тестирование работы функции
cout << i << "! = " << res << endl;
.\07_arrays\main.cpp
Массивы
Одномерные
``` cpp
  int intArray[10];
  // int - тип элементов массива
  // intArray - название массива
  // 10 - количество элементов
  // Нумерация элементов: 0..9

  // Записываем 23 в первый элемент массива
  intArray[0] = 23;
  intArray[1] = 10; // Второй элемент массива

  cout << intArray[0] + intArray[1] << endl;

  // Увеличить каждый элемент массива на 10
  for(int i = 0; i < 10; ++i)
    intArray[i] += 10;

  // Поиск минимума в массиве
  int minValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] < minValue)
      minValue = intArray[i];

  // Поиск максимума в массиве
  int maxValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] > maxValue)
      maxValue = intArray[i];

```

.\08_array_sort\main.cpp
Пример массива для сортировки
Выводим массив
for(int i = 0; i < N; ++i)
cout << A[i] << " ";
cout << endl;
Задание: отсортировать массив
{-2, 10, 1, 5, 6, 11}
{-2, [ 1, 10, 5, 6, 11 ] }
{-2, 1, [5, 10, 6, 11 ] }
SWAP
int temp = A[i];
A[i] = A[i+1];
A[i+1] = temp;
A[i] ^= A[i+1] ^= A[i] ^= A[i+1];
-----
| 1 | 0
-----
| 3 | 1
-----
| 5 | 2
-----
| 6 | 3  <-- i
-----
| 7 | 4
-----
Снова вывести на экран
.\08_array_task\main.cpp
ЗАДАЧА: посчитать сумму.
Нумерация элементов массива с 0
Все элементы на чётных местах взять с "+"
Все элементы на нечётных местах с "-"
Чётные: 0, 2, 4, 6 и т.д.
Нечётные: 1, 3, 5...
Сумма равна 0
Если элемент нечётный i % 2 == 1
если чётный i % 2 == 0
result += (i % 2) ? -A[i] : A[i];
Суммируем только чётные
Суммируем только нечётные
1 - 3 -2 -4 + 2 -10 = -16
.\09_array_task\main.cpp
Минимум в массиве
-----------------
Пользователь вводит количество элементов
в массиве.
Затем каждый элемент массива.
Все элементы - целые (int).
Вызывается функция, возвращающая
минимальный элемент массива
Массив содержит хотя бы 1 элемент.
Задание: найти минимум и вернуть
``` cpp
int arrayMin(int A[], int N) { // var N
  assert(N > 0);
  int curMin = A[0]; // Текущий минимум - первый элемент

  for(int i = 1; i < N; ++i)
    if(A[i] < curMin) // Если встретили элемент меньше
      curMin = A[i];     // => обновили текущий минимум

  return curMin;
}

void f() { // procedure F;
}

int main() {
  assert( 2 * 2 == 4 );

  // Ввод количества элементов массива
  int N;

  do {
    if(!cin.good()) {
      cin.clear();
      cin.ignore(std::numeric_limits<std::streamsize>::max(),
                 '\n');
    }

    assert(cin.good());
    cout << "N = ";
    cin >> N;
  } while(!cin.good() && N < 1);

  // Заводим массив A в динамической памяти
  int* A = new int[N];

  // Вводим массив с консоли
  for(int i = 0; i < N; ++i) {
    cout << "A[" << i << "] = ";
    cin >> A[i];

    if(!cin.good()) {
      cin.clear();
      cin.ignore(std::numeric_limits<std::streamsize>::max(),
                 '\n');
      cout << "Error: not a valid integer" << endl;
      --i;
    }
  }

  // Вызываем функцию поиска минимума и
  // выводим результат на консоль
  cout << "min = " << arrayMin(A, N) << endl;

  // Очищаем занимаемую динамическую память
  delete[] A;

  return 0;
}
```

.\09_arrays\main.cpp
2D массив
статической памяти и сохраняют своё значение между вызовами
myArray[0] = 3
myArray[1] = 10
myArray[2] = 20
myArray[3] = 43
.\09_arrays_2D\main.cpp
Поиск минимума
Сумма всех элементов
.\10_CallsCount\main.cpp
.\10_struct_C\main.c
Вывод комплексного числа на экран
Comp res = {a.re + b.re, a.im + b.im};
.\10_struct_C_2\main.c
.\10_stuct_Cpp\main.cpp
.\11_StackSize\main.cpp
.\11_show_in_memory_presentation\main.cpp
.\11_struct_C_Point2D\main.c
Математические функции
typedef определение_типа название_типа;
typedef struct Point P;
Расстояние между двумя точками
.\11_struct_cpp\main.cpp
Математические функции
typedef определение_типа название_типа;
typedef struct Point P;
Расстояние между двумя точками
.\13_strings_buffer_oveflow\main.cpp
Переполнение строки символов
Смертный Грех программиста №1 - источник уязвимостей
Ввод с клавиатуры
Ввод из файла
Получение пакета из сети
.\15_howework\main.cpp
Стек
Добавить значение на вершину
TODO: реализовать
Забрать значение и вернуть
TODO: реализовать
.\16_FileLog_DebugExample\main.cpp
.\17_task_large_arrays\main.cpp
``` cpp
const int SIZE = 100000;

// int A[]
// int &A[]
// /*, int arraySize*/ /* параметры */
int arrayMax(int* A) {
  // Предположим, что максимум это первый элемент
  int curMax = A[0];
  A[0] = -10; // Портим массив :)

  // Пробежим по остальным элементам массива
  // если какой-то элемент больше текущего
  // максимума, то запомним новый текущий максимум
  for(int i = 1; i < SIZE; ++i)
    if(A[i] > curMax)
      curMax = A[i];

  cout << "A[0] = " << A[0] << endl;

  return curMax;
}

int main() {
  // Массив в стеке
  int A[SIZE];

  // Заполняем случайными числами
  for(int i = 0; i < SIZE; ++i) {
    A[i] = rand() % 10000;    // от 0 до 9999
  }

  A[0] = -1;
  cout << "A[0] = " << A[0] << endl;

  cout << "max = " << arrayMax(A) << endl;

  cout << "A[0] = " << A[0] << endl;

  return 0;
}
```

.\18_cin_cout\main.cpp
cin >> p1.x >> p1.y;
cin.getline(str, 1024);
Вывести на экран точку 1
cin.clear();
.\19_memory\main.cpp
Заводим в динамической памяти массив из 100 элементов
с типом int
Удалили
*(intPtr + 19*sizeof(int));
.\20_not_init\main.cpp
.\C_struct\main.c
Структуры в чистом C
cout << "(" << p.x << ";" << p.y << ") ";
.\HomeWork_1\README.md

.\HomeWork_1\main.cpp
Домашнее задание - структуры данных
Сумма
TODO: Реализовать
Разность
TODO: Реализовать
Скалярное произведение векторов
TODO: Реализовать
Тестирование
.\HomeWork_2\README.md

.\HomeWork_2\main.cpp
Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N.
Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только
порядком слагаемых считаются одинаковыми.
-----------------------
Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
N - число для разложения
m - максимальное слагаемое в сумме
Цифры
Количество
Окончание рекурсии
x - текущее слагаемое
Сумма уменьшилась на x
Максимальное слагаемое - x
Убираем последнее слагаемое
Вводим число N
Вывод разложения на слагаемые
.\HomeWork_2_dynmemory\main.cpp
Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.
-----------------------
Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
Цифры
N - число для разложения
m - максимальное слагаемое в сумме
K - количество цифр
Окончание рекурсии
x - текущее слагаемое
Сумма уменьшилась на x
Максимальное слагаемое - x
Вводим число N
Цифры
new int[N]; - возвращает указатель на int
Вывод разложения на слагаемые
A = new type[SIZE]    delete[] A  -- создание и удаление массива
в динамической памяти
A = new type;  delete A; -- создание и удаление одиночного
объекта
.\Memory\main.cpp
Статическая память
int veryBigArray[SIZE];
int *a,b;
int *a; int b;
int *a,*b; - теперь оба указателя
a = (int *)12312;
.\OrAndExample\main.cpp
.\RussianInput\main.cpp
.\RussianLocale\main.cpp
SetConsoleOutputCP(65001);
SetConsoleCP(65001);
setlocale(LC_ALL, "Russian.UTF-8");
.\Uravnenie\main.cpp
----------------------------------------
.\cpp_dynamic\main.cpp
delete и delete[]
-----------------
Пусть у нас есть структура
``` cpp
struct Point {
  double x, y;
};
```

``` cpp
  // Заводим массив в динамической памяти
  int* intArray;
  intArray = new int[1000]; // new со скобками []
  intArray[0] = 10;
  intArray[1] = 23;
  delete[] intArray; // И delete должен быть со скобками

  Point* p = new Point;
  delete p; // delete без скобочек []
```

.\factorial\main.cpp
Без: using namespace std;
Win1251 и в исходном тексте и в консоли
.\function_declaration\main.cpp
Функции
...
using namespace my;
.\lesson2_eq\main.cpp
a^=b^=a^=b; // XOR - исключающее или
int g = f++ + f++ + f++;
g = f++;
cout << "a = " << a << " b = " << b << endl;
.\malloc_free\main.c
Память не отведена
Освобождаем динамическую память
чуть постарше 1
Два порядка байтов:
* Big-endian - старший байт в конце (IBM, майнфреймы, Sun Sparc и т.д.)
* Little-endian - младший байт первый (Intel и совместимые)
Little - основное преимущество - можно начинать складывать младшие байты
не дожидаясь пока старшие "прийдут" по шине
.\min_array\main.cpp
Поиск минимума в массиве
Пробежим по остальному массиву
каждый раз добавляя по одному элементу
и если он меньше текущего минимума
обновим минимум
Пробежим по остальному массиву
каждый раз добавляя по одному элементу
и если он меньше текущего минимума
обновим минимум
Индексы: 0  1  2  3
Вызов функции, ожидаем на выходе 4
.\overload_c\main.c
Универсальный максимум в стиле "C"
.\pointers\main.cpp
Исходное значение не меняется
Передаём ссылку -> меняем исходное значение
Передаём указатель -> меняем исходное значение
.\pointers\pointers2\main.cpp
Пример на ссылки и указатели
i - указатель, т.е. это
переменная содержащая адрес
i = &c;
.\references\main.cpp
Ссылки в C++
В с теперь будет адрес d
example1();
example3();
.\stack\main.cpp
Элемент стека
``` cpp
struct StackElement {
  int value; // Значение элемента стека
  StackElement* next; // Указатель на следующий элемент стека
};
```

``` cpp
class Stack { // Можно использовать struct
  StackElement* root;
```

Конструктор:
------------
* называется так же как класс
* нет возвращаемого значения
* параметры как у обычных методов
* цель - инициализация объекта
``` cpp
  Stack() : root(NULL) { }
```

Деструктор
----------
Очистка памяти, освобождение ресурсов
``` cpp
  ~Stack() {
    while(root != NULL) {
      StackElement* saveForDelete = root;
      root = root->next;
      delete saveForDelete;
    }
  }
```

Поместить значение на вершину стека
``` cpp
  void push(int newValue) {
    // Создали новый элемент стека с новым значением
    StackElement* newElement = new StackElement;
    newElement->value = newValue;
    // "Подвешиваем" root к новому элементу
    newElement->next = root;
    // Делаем новый элемент первым в списке
    root = newElement;
  }
```

Получить значение с вершины стека
``` cpp
  int pop() {
    if(root == NULL) {
      cout << "Stack is empty!" << endl;
      return 0;
    }

    // Получаем верхний элемент
    StackElement* topElement = root;
    // Получаем значение верхнего элемента
    int value = topElement->value;
    // Переставим корень списка на след. элемент
    root = topElement->next;
    // Очистим память
    delete topElement;
    // Вернём значение
    return value;
  }
```

Показать все элементы
``` cpp
  void show() {
    for(StackElement* cur = root;
        cur != NULL;
        cur = cur->next)
      cout << cur->value << endl;
  }
```

Использование стека
``` cpp
  Stack s;
  s.push(2);
  s.push(4);
  s.push(5);
  s.show();
  cout << "pop result = " << s.pop() << endl;
  s.show();
```

Д.з. однонаправленный список
----------------------------
.\switch\main.cpp
Win1251 и в исходном тексте и в консоли
system("chcp 65001");
freopen()
.\union\main.cpp
typedef Определение_типа Имя_нового_типа;
Число:    01101110  00001101
Ном.бита: 76543210         1
.\union_2\main.cpp
.\z_homework.md
Домашнее задание - рекурсия
---------------------------
  ЗАДАНИЕ:
 Пользователь вводит натуральное число N.
 Нужно вывести все способы разложить его на слагаемые.
 Способы отличающиеся только
 порядком слагаемых считаются одинаковыми.

Например N = 4:
* 4 = 4
* 4 = 3 + 1
* 4 = 2 + 2
* 4 = 2 + 1 + 1
* 4 = 1 + 1 + 1 + 1

